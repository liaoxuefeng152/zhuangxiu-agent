"""
è£…ä¿®å†³ç­–Agent - æ•°æ®åº“é…ç½®
"""
from sqlalchemy.dialects import registry
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base
from sqlalchemy.pool import QueuePool
from app.core.config import settings
import logging

# ğŸ‘‡ å…³é”®ï¼šåœ¨ä»»ä½• SQLAlchemy æ“ä½œå‰æ³¨å†Œ asyncpg dialect
registry.register(
    "postgresql.asyncpg",
    "sqlalchemy.dialects.postgresql.asyncpg",
    "AsyncpgDialect"
)

logger = logging.getLogger(__name__)

# åˆ›å»ºå¼‚æ­¥å¼•æ“ï¼ˆä¼˜åŒ–è¿æ¥æ± é…ç½®ï¼‰
engine = create_async_engine(
    settings.DATABASE_URL,  # åº”ä¸º postgresql+asyncpg://...
    poolclass=QueuePool,
    pool_size=settings.DATABASE_POOL_SIZE,
    max_overflow=settings.DATABASE_MAX_OVERFLOW,
    pool_timeout=settings.DATABASE_POOL_TIMEOUT,
    pool_recycle=settings.DATABASE_POOL_RECYCLE,
    pool_pre_ping=True,  # å¯ç”¨è¿æ¥å¥åº·æ£€æŸ¥
    echo=settings.DEBUG,
    future=True,
    connect_args={
        "server_settings": {
            "application_name": settings.APP_NAME,
        }
    },
)

# åˆ›å»ºå¼‚æ­¥ä¼šè¯å·¥å‚
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)

# å£°æ˜åŸºç±»
Base = declarative_base()


async def get_pool_status() -> dict:
    """
    è·å–è¿æ¥æ± çŠ¶æ€

    Returns:
        è¿æ¥æ± çŠ¶æ€ä¿¡æ¯å­—å…¸
    """
    pool = engine.pool
    return {
        "size": pool.size(),
        "checked_in": pool.checkedin(),
        "checked_out": pool.checkedout(),
        "overflow": pool.overflow(),
        "invalidated": pool.invalidated(),
    }


async def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“"""
    try:
        async with engine.begin() as conn:
            # å¯¼å…¥æ‰€æœ‰æ¨¡å‹ä»¥ç¡®ä¿å®ƒä»¬è¢«æ³¨å†Œ
            from app.models import User, Quote, Contract, CompanyScan, Order, Construction

            # åˆ›å»ºæ‰€æœ‰è¡¨ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
            if settings.DEBUG:
                await conn.run_sync(Base.metadata.create_all)
                logger.info("æ•°æ®åº“è¡¨åˆ›å»ºå®Œæˆ")
            else:
                logger.info("ç”Ÿäº§ç¯å¢ƒï¼Œè·³è¿‡è‡ªåŠ¨åˆ›å»ºè¡¨")
    except Exception as e:
        logger.error(f"æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: {e}", exc_info=True)
        raise


async def get_db() -> AsyncSession:
    """
    è·å–æ•°æ®åº“ä¼šè¯ï¼ˆå¸¦äº‹åŠ¡ç®¡ç†ï¼‰

    Yields:
        AsyncSession: æ•°æ®åº“ä¼šè¯
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
            await session.commit()  # æäº¤äº‹åŠ¡
        except Exception as e:
            logger.error(f"æ•°æ®åº“ä¼šè¯å¼‚å¸¸: {e}", exc_info=True)
            await session.rollback()  # å›æ»šäº‹åŠ¡
            raise
        finally:
            await session.close()


async def close_db():
    """å…³é—­æ•°æ®åº“è¿æ¥"""
    await engine.dispose()
    logger.info("æ•°æ®åº“è¿æ¥å·²å…³é—­")
